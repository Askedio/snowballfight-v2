# client
import Phaser from "phaser";
import { io } from "socket.io-client";

const socket = io("https://server.willbowman.dev");

const TICK_DURATION = 1000 / 60; // Define tick duration globally

class GameScene extends Phaser.Scene {
  private players: Record<string, Phaser.GameObjects.Arc> = {};
  private bullets: Record<string, Phaser.GameObjects.Arc> = {};
  private playerHealth: Record<string, Phaser.GameObjects.Text> = {};
  private myPlayerId: string | null = null;
  private cursors: Phaser.Types.Input.Keyboard.CursorKeys | null = null;
  private wasd: Record<string, Phaser.Input.Keyboard.Key> | null = null;
  private speed: number = 5;

  constructor() {
    super({ key: "GameScene" });
  }

  preload() {}

  create() {
    this.cursors = this.input.keyboard?.createCursorKeys();
  this.wasd = {
    W: this.input.keyboard?.addKey(Phaser.Input.Keyboard.KeyCodes.W),
    A: this.input.keyboard?.addKey(Phaser.Input.Keyboard.KeyCodes.A),
    S: this.input.keyboard?.addKey(Phaser.Input.Keyboard.KeyCodes.S),
    D: this.input.keyboard?.addKey(Phaser.Input.Keyboard.KeyCodes.D),
  };

  // Add input event listeners
  this.input.keyboard.on("keydown", (event: KeyboardEvent) => {
    this.handleInput(event, true);
  });

  this.input.keyboard.on("keyup", (event: KeyboardEvent) => {
    this.handleInput(event, false);
  });

  window.addEventListener("blur", () => {
    console.log("Window lost focus, clearing inputs");
    socket.emit("clearInputs");
  });


    this.input.on("pointerdown", (pointer: Phaser.Input.Pointer) => {
      if (this.myPlayerId) {
        const myPlayer = this.players[this.myPlayerId];
        if (myPlayer) {
          const dx = pointer.x - myPlayer.x;
          const dy = pointer.y - myPlayer.y;
          const magnitude = Math.sqrt(dx * dx + dy * dy);

          console.log("shootBullet");

          // Emit shootBullet event
          socket.emit("shootBullet", {
            dx: (dx / magnitude) * 10,
            dy: (dy / magnitude) * 10,
          });
        }
      }
    });

    // Handle server initialization
    socket.on("initialize", (data: { tick: number; players: Record<string, any>; bullets: any[] }) => {
      Object.keys(data.players).forEach((id) => {
        this.addPlayer(id, data.players[id]);
      });
    });

    // Handle new players joining
    socket.on("playerJoined", (player: PlayerState) => {
      console.log("New player joined:", player);
      this.addPlayer(player.id, player);
    });

    socket.on("stateUpdate", (data: { tick: number; players: Record<string, { x: number; y: number; health: number }> }) => {
      Object.keys(data.players).forEach((id) => {
        const serverPlayer = data.players[id];
        
        // If the player does not exist locally, create it
        if (!this.players[id]) {
          this.addPlayer(id, serverPlayer);
        } else {
          const current = this.players[id];

          const healthText = this.playerHealth[id];
          if (healthText) {
            healthText.setText(HP: ${serverPlayer.health});
          }
        
          // Skip tween for the local player
       //   if (id === this.myPlayerId) return;
    
          // Calculate the distance between the current and server positions
          const dx = serverPlayer.x - current.x;
          const dy = serverPlayer.y - current.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
    
          // Only tween if the player is far enough from the server state
          if (distance > 0) {
            // Calculate duration based on distance and speed
            const speed = 200; // You could retrieve this from the server if you want dynamic speeds
            const duration = (distance / speed) * 1000; // Duration in milliseconds
    
            this.tweens.add({
              targets: current,
              x: serverPlayer.x,
              y: serverPlayer.y,
              duration: 10,
            });
          }
    
          // Update the player's health text
         
        }
      });
    
      // Handle bullets
      Object.keys(this.bullets).forEach((id) => {
        if (!data.bullets.find((bullet) => bullet.id === id)) {
          this.bullets[id]?.destroy();
          delete this.bullets[id];
        }
      });
    
      // Render new bullets
      data.bullets.forEach((bullet) => {
        if (!this.bullets[bullet.id]) {
          this.bullets[bullet.id] = this.add.circle(bullet.x, bullet.y, 2, 0xff0000);
        } else {
          this.bullets[bullet.id].setPosition(bullet.x, bullet.y);
        }
      });
    });
    
    
    socket.on("connect", () => {
      if (!socket?.id) return;
      this.myPlayerId = socket.id;
    });

    // Handle player leaving
    socket.on("playerLeft", (playerId: string) => {
      console.log(Player disconnected: ${playerId});
      this.removePlayer(playerId);
    });

    // Handle player death
    socket.on("playerDied", (playerId: string) => {
      console.log(Player died: ${playerId});
      this.removePlayer(playerId);
    });
  }

  update(time: number, delta: number) {
   
  
    // Update HP box position
    Object.keys(this.players).forEach((id) => {
      const player = this.players[id];
      const healthText = this.playerHealth[id];
      if (player && healthText) {
        healthText.x = player.x - 15;
        healthText.y = player.y - 20;
      }
    });
  }
  private addPlayer(id: string, player: any) {
    this.players[id] = this.add.circle(player.x, player.y, 10, 0x00ff00);
    this.playerHealth[id] = this.add.text(
      player.x - 15,
      player.y - 20,
      HP: ${player.health},
      { fontSize: "10px", color: "#ffffff" }
    );
  }

  private removePlayer(playerId: string) {
    if (this.players[playerId]) {
      this.players[playerId].destroy();
      delete this.players[playerId];
    }

    if (this.playerHealth[playerId]) {
      this.playerHealth[playerId].destroy();
      delete this.playerHealth[playerId];
    }
  }

  handleInput(event: KeyboardEvent, isActive: boolean) {
    const actionMap = {
      ArrowLeft: "left",
      ArrowRight: "right",
      ArrowUp: "up",
      ArrowDown: "down",
      w: "up",
      a: "left",
      s: "down",
      d: "right",
    };
  
    const action = actionMap[event.key];

    console.log(action, event)
    if (action) {
      socket.emit("input", { action, isActive });
    }
  }
}




const config: Phaser.Types.Core.GameConfig = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  parent: "game-container",
  
  scene: GameScene,
};

const game = new Phaser.Game(config);